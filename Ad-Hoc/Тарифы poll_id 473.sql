
diagnostic helpstats on for session;


--2022
/*week 39*/ call uat_ca.as_proc_473 (timestamp'2022-09-26 00:00:00', timestamp'2022-10-03 00:00:00');       --1 мин. 39 сек.
/*week 40*/ call uat_ca.as_proc_473 (timestamp'2022-10-03 00:00:00', timestamp'2022-10-10 00:00:00');
/*week 41*/ call uat_ca.as_proc_473 (timestamp'2022-10-10 00:00:00', timestamp'2022-10-17 00:00:00');
/*week 42*/ call uat_ca.as_proc_473 (timestamp'2022-10-17 00:00:00', timestamp'2022-10-24 00:00:00');
/*week 43*/ call uat_ca.as_proc_473 (timestamp'2022-10-24 00:00:00', timestamp'2022-10-31 00:00:00');
/*week 44*/ call uat_ca.as_proc_473 (timestamp'2022-10-31 00:00:00', timestamp'2022-11-07 00:00:00');
/*week 45*/ call uat_ca.as_proc_473 (timestamp'2022-11-07 00:00:00', timestamp'2022-11-14 00:00:00');
/*week 46*/ call uat_ca.as_proc_473 (timestamp'2022-11-14 00:00:00', timestamp'2022-11-21 00:00:00');
/*week 47*/ call uat_ca.as_proc_473 (timestamp'2022-11-21 00:00:00', timestamp'2022-11-28 00:00:00');
/*week 48*/ call uat_ca.as_proc_473 (timestamp'2022-11-28 00:00:00', timestamp'2022-12-05 00:00:00');
/*week 49*/ call uat_ca.as_proc_473 (timestamp'2022-12-05 00:00:00', timestamp'2022-12-12 00:00:00');
/*week 50*/ call uat_ca.as_proc_473 (timestamp'2022-12-12 00:00:00', timestamp'2022-12-19 00:00:00');
/*week 51*/ call uat_ca.as_proc_473 (timestamp'2022-12-19 00:00:00', timestamp'2022-12-26 00:00:00');
/*week 52*/ call uat_ca.as_proc_473 (timestamp'2022-12-26 00:00:00', timestamp'2023-01-02 00:00:00');

--2023
/*week 1*/  call uat_ca.as_proc_473 (timestamp '2023-01-02 00:00:00', timestamp '2023-01-09 00:00:00');
/*week 2*/  call uat_ca.as_proc_473 (timestamp '2023-01-09 00:00:00', timestamp '2023-01-16 00:00:00');
/*week 3*/  call uat_ca.as_proc_473 (timestamp '2023-01-16 00:00:00', timestamp '2023-01-23 00:00:00');
/*week 4*/  call uat_ca.as_proc_473 (timestamp '2023-01-23 00:00:00', timestamp '2023-01-30 00:00:00');
/*week 5*/  call uat_ca.as_proc_473 (timestamp '2023-01-30 00:00:00', timestamp '2023-02-06 00:00:00');
/*week 6*/  call uat_ca.as_proc_473 (timestamp '2023-02-06 00:00:00', timestamp '2023-02-13 00:00:00');
/*week 7*/  call uat_ca.as_proc_473 (timestamp '2023-02-13 00:00:00', timestamp '2023-02-20 00:00:00');
/*week 8*/  call uat_ca.as_proc_473 (timestamp '2023-02-20 00:00:00', timestamp '2023-02-27 00:00:00');
/*week 9*/  call uat_ca.as_proc_473 (timestamp '2023-02-27 00:00:00', timestamp '2023-03-06 00:00:00');
/*week 10*/ call uat_ca.as_proc_473 (timestamp '2023-03-06 00:00:00', timestamp '2023-03-13 00:00:00');
/*week 11*/ call uat_ca.as_proc_473 (timestamp '2023-03-13 00:00:00', timestamp '2023-03-20 00:00:00');
/*week 12*/ call uat_ca.as_proc_473 (timestamp '2023-03-20 00:00:00', timestamp '2023-03-27 00:00:00');
/*week 13*/ call uat_ca.as_proc_473 (timestamp '2023-03-27 00:00:00', timestamp '2023-04-03 00:00:00');
/*week 14*/ call uat_ca.as_proc_473 (timestamp '2023-04-03 00:00:00', timestamp '2023-04-10 00:00:00');
/*week 15*/ call uat_ca.as_proc_473 (timestamp '2023-04-10 00:00:00', timestamp '2023-04-17 00:00:00');
/*week 16*/ call uat_ca.as_proc_473 (timestamp '2023-04-17 00:00:00', timestamp '2023-04-24 00:00:00');
/*week 17*/ call uat_ca.as_proc_473 (timestamp '2023-04-24 00:00:00', timestamp '2023-05-01 00:00:00');
/*week 18*/ call uat_ca.as_proc_473 (timestamp '2023-05-01 00:00:00', timestamp '2023-05-08 00:00:00');
/*week 19*/ call uat_ca.as_proc_473 (timestamp '2023-05-08 00:00:00', timestamp '2023-05-15 00:00:00');
/*week 20*/ call uat_ca.as_proc_473 (timestamp '2023-05-15 00:00:00', timestamp '2023-05-22 00:00:00');
/*week 21*/ call uat_ca.as_proc_473 (timestamp '2023-05-22 00:00:00', timestamp '2023-05-29 00:00:00');
/*week 22*/ call uat_ca.as_proc_473 (timestamp '2023-05-29 00:00:00', timestamp '2023-06-05 00:00:00');
/*week 23*/ call uat_ca.as_proc_473 (timestamp '2023-06-05 00:00:00', timestamp '2023-06-12 00:00:00');
/*week 24*/ call uat_ca.as_proc_473 (timestamp '2023-06-12 00:00:00', timestamp '2023-06-19 00:00:00');
/*week 25*/ call uat_ca.as_proc_473 (timestamp '2023-06-19 00:00:00', timestamp '2023-06-26 00:00:00');
/*week 26*/ call uat_ca.as_proc_473 (timestamp '2023-06-26 00:00:00', timestamp '2023-07-03 00:00:00');
/*week 27*/ call uat_ca.as_proc_473 (timestamp '2023-07-03 00:00:00', timestamp '2023-07-10 00:00:00');


-- Для просмотра рассчитанных дней в момент работы процедуры, либо по ее завершению используйте запрос по таблице логов:
lock row for access
select * from uat_ca.mc_logs t1
where t1.ProcessName = 'nps_459_2'
 and t1.logdate > current_timestamp(0) - interval '1' month
order by logdate desc;


select top 100 * from uat_ca.v_poll_473;        --view для аналитики и dashboard
select top 100 * from uat_ca.poll_id_473;       --витрина с данными


--1 недельная динамика
select
 weeknumber_of_year (create_date, 'ISO') as "неделя",
 trunc (create_date,'iw') as first_day_week,
 count (distinct subs_id) dis_subs,
 count (distinct msisdn) dis_msisdn,
 count (*) as row_cnt,
 dis_subs - row_cnt as diff_subs,
 dis_msisdn - row_cnt as diff_msisdn
from uat_ca.v_poll_473
group by 1,2
order by 2 desc;

--2 месячная динамика
select
 trunc (create_date,'mm') as "Месяц",
 count (distinct subs_id) dis_subs,
 count (distinct msisdn) dis_msisdn,
 count (*) as row_cnt,
 dis_subs - row_cnt as diff_subs,
 dis_msisdn - row_cnt as diff_msisdn
from uat_ca.v_poll_473
group by 1
order by 1 desc;

--3 дневная динамика
select
 create_date,
 count (distinct subs_id) dis_subs,
 count (distinct msisdn) dis_msisdn,
 count (*) as row_cnt,
 dis_subs - row_cnt as diff_subs,
 dis_msisdn - row_cnt as diff_msisdn
from uat_ca.v_poll_473
group by 1
order by 1 desc;


--=================================================================================================

--имя точки контакта
select * from prd2_odw_v.smspoll_polls
where 1=1
 and poll_id in (473);

473     Детракторы_тариф Telesales

--уникальные q_text
select * from prd2_odw_v.smspoll_poll_contents
where 1=1
 and poll_id = 473
-- and q_step = 6
order by 3, 1;


--1
Здравствуйте, это Tele2. Нам очень важно ваше мнение. Пожалуйста, ответьте на три простых вопроса.
Вчера вам звонил сотрудник Tele2 по вопросу тарифов/услуг. Был ли решен ваш вопрос? Отправьте ответное
SMS c цифрой, где 1 - Решен, 2 - Не решен. SMS бесплатное. 


--2
Был ли полезен для вас данный звонок? Отправьте ответное SMS c цифрой, где: 1 - звонок полезен, 2- звонок бесполезен.

--3
Оцените, пожалуйста, вашу готовность делиться обратной связью о продуктах и услугах компании Tele2.
Благодаря вашим ответам, мы становимся лучше. Отправьте в ответ цифру, где 1 - скорее да, 2 - скорее нет.

--4
Спасибо! Ваше мнение для нас очень ценно. Если на один из вопросов Вы ответили «2», в ответном SMS
отправьте, пожалуйста, комментарий о причине вашей оценки.


--
select
 weeknumber_of_year (a.created_date, 'ISO') as "неделя",
 trunc (a.created_date,'iw') as first_day_week,
 cast(a.created_date as date) as create_date,
 count(distinct msisdn)
from prd2_odw_v.smspoll_communication_lists a
inner join prd2_odw_v.smspoll_poll_lists b on a.sub_list_id = b.sub_list_id
 and b.created_date >= timestamp '2022-10-01 00:00:00'
 and b.created_date < timestamp '2022-10-01 00:00:00'
 and b.poll_id = 473
where 1=1
 and a.created_date >= timestamp '2022-10-01 00:00:00'
 and a.created_date < timestamp '2022-10-01 00:00:00'
group by 1,2,3
order by 3;


--c 2022-09-27

--==
select
 cast(created_dttm as date) as created_date,
 poll_id,
 count(distinct subs_id),
 count(*)
from prd2_dds_v.smspoll_detail
where 1=1
 and poll_id in (473)
 and created_dttm >= timestamp '2022-01-24 00:00:00'
 and created_dttm < timestamp '2023-05-01 00:00:00'
group by 1,2
order by 1 desc
;


--==================================================================================================

REPLACE PROCEDURE uat_ca.as_as_proc_473 (in stime timestamp, in etime timestamp)
SQL SECURITY INVOKER
BEGIN

-- объявление переменных
DECLARE proc varchar(50);
DECLARE LOAD_ID int;
DECLARE ERR_MSG VARCHAR(4000) DEFAULT '';
DECLARE ERR_SQLCODE INT;
DECLARE ERR_SQLSTATE INT;
DECLARE ROW_CNT INT;

-- Ошибка на этапе запуска SQL кода
DECLARE EXIT HANDLER FOR SqlException
BEGIN
SET ERR_SQLCODE = Cast(SqlCode AS INTEGER);
SET ERR_SQLSTATE = Cast(SqlState AS INTEGER);
SELECT ErrorText INTO :ERR_MSG FROM dbc.errormsgs WHERE Errorcode = :ERR_SQLCODE;
CALL uat_ca.prc_debug (:proc, :load_id, session, 0, 'An error occured during execution: ' || :ERR_MSG);
END;

SET proc = 'nps_473_as';           -- наименование расчета

select max(zeroifnull(loadid)+1) into load_id
from uat_ca.mc_logs;

-- логирование начала расчета данных
CALL uat_ca.prc_debug (proc,:load_id,session,0,'START');


--=================================================================================================

--01 целевая группа

--drop table target_group;

create multiset volatile table target_group, no log (                                       --target_group = soa
 created_date timestamp(0),
 treatment_code varchar(9) character set unicode not casespecific,
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 q_step byteint,
 mark varchar(1024) character set unicode not casespecific,
 load_id integer)
primary index (msisdn)
on commit preserve rows;


insert into target_group
select
 created_dttm as created_date,
 treatment_code,
 msisdn,
 subs_id,
 q_step,
 mark,
-- load_id
 :load_id
from prd2_dds_v.smspoll_detail
where 1=1
 and poll_id in (473)
 and created_dttm >= :stime
 and created_dttm < :etime
-- and created_dttm >= timestamp '2023-04-24 00:00:00'
-- and created_dttm < timestamp '2023-05-01 00:00:00'
;

--select top 100 * from target_group;
--select top 100 * from target_group where msisdn = '79044505246';


-- логирование текущего расчета
get diagnostics ROW_CNT = row_count;
CALL uat_ca.prc_debug (proc,:load_id,session,null,'INTERVAL_DATE '|| to_char(cast(stime as date),'DD.MM.YYYY') || '_' ||to_char(cast(etime as date),'DD.MM.YYYY') || ' Всего строк: ' || trim(cast(row_cnt as VARCHAR(4000) CHARACTER SET UNICODE NOT CASESPECIFIC)));


--02 транспонирование

COLLECT STATISTICS
 COLUMN (SUBS_ID),
 COLUMN (MSISDN),
 COLUMN (TREATMENT_CODE),
 COLUMN (CREATED_DATE ,TREATMENT_CODE ,MSISDN ,SUBS_ID ,LOAD_ID),
 COLUMN (LOAD_ID)
ON target_group;

--drop table transpon;

create multiset volatile table transpon, no log (                               --transpon = soa_2
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 create_date date format 'yy/mm/dd',
 treatment_code varchar(9) character set unicode not casespecific,
 mark_1 varchar(1024) character set unicode not casespecific,
 mark_2 varchar(1024) character set unicode not casespecific,
 mark_3 varchar(1024) character set unicode not casespecific,
 mark_4 varchar(1024) character set unicode not casespecific,
 load_id integer)
primary index (msisdn)
on commit preserve rows;


insert into transpon
select
 msisdn,
 subs_id,
 cast(created_date as date) as create_date,
 treatment_code,
 max (step_1) as mark_1,
 max (step_2) as mark_2,
 max (step_3) as mark_3,
 max (step_4) as mark_4,
 load_id
from (
select * from target_group pivot (max(mark) for q_step in (
 '1' as step_1,
 '2' as step_2,
 '3' as step_3,
 '4' as step_4
)) t2
) a
--where msisdn= '79044505246'
group by 1,2,3,4,9
;

--select * from transpon;


--03 Step 1 Решение вопроса
/*
Здравствуйте, это Tele2. Нам очень важно ваше мнение. Пожалуйста, ответьте на три простых вопроса.
Вчера вам звонил сотрудник Tele2 по вопросу тарифов/услуг. Был ли решен ваш вопрос? Отправьте ответное
SMS c цифрой, где 1 - Решен, 2 - Не решен. SMS бесплатное. 
*/
create multiset volatile table target_group_step1, no log (
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_1 varchar(1024) character set unicode not casespecific,
 ans_1 varchar(1024) character set unicode not casespecific)
primary index (msisdn)
on commit preserve rows;


insert into target_group_step1
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_1,
 case when a.ans_1 is null then null
      when a.ans_1 = 1 then 'Решен'
      when a.ans_1 = 2 then 'Не решен'
      when a.ans_1 = -1 then 'Другое'
      else '-1' end as ans_1
from (
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_1,
 length (oreplace(oreplace(oreplace(upper(a.mark_1),' ',''),',',''),'.','')) length_step_1,
 case when a.mark_1 is null then null
      when length_step_1 = 1
      then case when regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_1),' ',''),',',''),'.',''), '[1-9]\d{0,2}') in ('1', '2')
                then regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_1),' ',''),',',''),'.',''), '[1-9]\d{0,2}') else '-1' end
      else '-1' end as ans_1
from transpon a
) a
;


--select * from target_group_step1;


--==04 Step 2 Полезность звонка
/*
Был ли полезен для вас данный звонок? Отправьте ответное SMS c цифрой, где: 1 - звонок полезен, 2- звонок бесполезен.
*/

--drop table target_group_step2;

create multiset volatile table target_group_step2, no log (                                         --target_group_step2 = soa_step2
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_2 varchar(1024) character set unicode not casespecific,
 ans_2 varchar(1024) character set unicode not casespecific)
primary index (msisdn)
on commit preserve rows;

insert into target_group_step2
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_2,
 case when a.ans_2 is null then null
      when a.ans_2 = 1 then 'Решен'
      when a.ans_2 = 2 then 'Не решен'
      when a.ans_2 = -1 then 'Другое'
      else '-1' end as ans_2
from (
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_2,
 length (oreplace(oreplace(oreplace(upper(a.mark_2),' ',''),',',''),'.','')) length_step_2,
 case when a.mark_2 is null then null
      when length_step_2 = 1
      then case when regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_2),' ',''),',',''),'.',''), '[1-9]\d{0,2}') in ('1', '2')
                then regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_2),' ',''),',',''),'.',''), '[1-9]\d{0,2}') else '-1' end
      else '-1' end as ans_2
from transpon a
) a
;

--select * from target_group_step2;


--==05 Step 3 Готовность к обратной связи
/*
Оцените, пожалуйста, вашу готовность делиться обратной связью о продуктах и услугах компании Tele2.
Благодаря вашим ответам, мы становимся лучше. Отправьте в ответ цифру, где 1 - скорее да, 2 - скорее нет.
*/

--delete target_group_step3_1;
--delete target_group_step3;

create multiset volatile table target_group_step3, no log (                                         --target_group_step2 = soa_step2
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_3 varchar(1024) character set unicode not casespecific,
 ans_3 varchar(1024) character set unicode not casespecific)
primary index (msisdn)
on commit preserve rows;

insert into target_group_step3
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_3,
 case when a.ans_3 is null then null
      when a.ans_3 = 1 then 'Да'
      when a.ans_3 = 2 then 'Нет'
      when a.ans_3 = -1 then 'Другое'
      else '-1' end as ans_3
from (
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_3,
 length (oreplace(oreplace(oreplace(upper(a.mark_3),' ',''),',',''),'.','')) length_step_3,
 case when a.mark_3 is null then null
      when length_step_3 = 1
      then case when regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_3),' ',''),',',''),'.',''), '[1-9]\d{0,2}') in ('1', '2')
                then regexp_substr(oreplace(oreplace(oreplace(upper(a.mark_3),' ',''),',',''),'.',''), '[1-9]\d{0,2}') else '-1' end
      else '-1' end as ans_3
from transpon a
) a
;

--select * from target_group_step3;


--==06 Step 4
/*
Спасибо! Ваше мнение для нас очень ценно. Если на один из вопросов Вы ответили «2», в ответном SMS
отправьте, пожалуйста, комментарий о причине вашей оценки.
*/


--==07 Итоговая сборка
COLLECT STATISTICS
 COLUMN (MSISDN),
 COLUMN (CREATE_DATE ,MSISDN)
ON transpon;

COLLECT STATISTICS
 COLUMN (MSISDN),
 COLUMN (CREATE_DATE ,MSISDN)
ON target_group_step1;

COLLECT STATISTICS
 COLUMN (MSISDN),
 COLUMN (CREATE_DATE ,MSISDN)
ON target_group_step2;

COLLECT STATISTICS
 COLUMN (MSISDN),
 COLUMN (CREATE_DATE ,MSISDN)
ON target_group_step3;


--drop table proc_fin;

--select top 100 * from target_group_step1_1;      --step_1: cuvo
--select top 100 * from target_group_step2;        --step_2: mark_2
--select top 100 * from target_group_step3;        --step_3: mark_3


create multiset volatile table proc_fin, no log (                                           --proc_fin = soa_fin
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_1 varchar(1024) character set unicode not casespecific,
 mark_2 varchar(1024) character set unicode not casespecific,
 mark_3 varchar(1024) character set unicode not casespecific,
 mark_4 varchar(1024) character set unicode not casespecific,
 ans_1 varchar(1024) character set unicode not casespecific,
 ans_2 varchar(1024) character set unicode not casespecific,
 ans_3 varchar(1024) character set unicode not casespecific,
 load_id integer)
primary index (msisdn)
on commit preserve rows;


insert into proc_fin
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 t1.mark_1,              --Решение вопроса
 t2.mark_2,              --Полезность звонка
 t3.mark_3,              --Готовность делиться
 a.mark_4,               --mark_4 (step_4) Комментарий
 t1.ans_1,
 t2.ans_2,
 t3.ans_3,
 a.load_id
from transpon a
--
left join target_group_step1    t1 on a.msisdn = t1.msisdn and a.create_date = t1.create_date    --Решение вопроса
left join target_group_step2    t2 on a.msisdn = t2.msisdn and a.create_date = t2.create_date    --Полезность звонка
left join target_group_step3    t3 on a.msisdn = t3.msisdn and a.create_date = t3.create_date    --Готовность делиться
;

--select top 100 * from transpon;
--select * from proc_fin;



--==08 Исключение долетов

--drop table proc_tmp;

create multiset volatile table proc_tmp ,no log (                                       --proc_tmp = subs_tmp
 create_date date format 'yy/mm/dd',
 subs_id decimal(12,0),
 msisdn varchar(20) character set unicode not casespecific)
primary index (subs_id)
on commit preserve rows;


insert into proc_tmp
select create_date, subs_id, msisdn from proc_fin
qualify row_number () over (partition by msisdn order by create_date) = 1
;


COLLECT STATISTICS
 COLUMN (SUBS_ID),
 COLUMN (CREATE_DATE ,SUBS_ID)
ON proc_fin;

COLLECT STATISTICS
 COLUMN (SUBS_ID),
 COLUMN (CREATE_DATE ,SUBS_ID)
ON proc_tmp;


--drop table proc_fin2;

create multiset volatile table proc_fin2, no log (
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_1 varchar(1024) character set unicode not casespecific,
 mark_2 varchar(1024) character set unicode not casespecific,
 mark_3 varchar(1024) character set unicode not casespecific,
 mark_4 varchar(1024) character set unicode not casespecific,
 ans_1 varchar(1024) character set unicode not casespecific,
 ans_2 varchar(1024) character set unicode not casespecific,
 ans_3 varchar(1024) character set unicode not casespecific,
 load_id integer)
primary index (msisdn)
on commit preserve rows;


--абоненты с долетами
insert into proc_fin2
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 coalesce(a.mark_1,  t1.mark_1) as mark_1,
 coalesce(a.mark_2,  t1.mark_2) as mark_2,
 coalesce(a.mark_3,  t1.mark_3) as mark_3,
 coalesce(a.mark_4,  t1.mark_4) as mark_4,
 coalesce(a.ans_1,   t1.ans_1) as ans_1,
 coalesce(a.ans_2,   t1.ans_2) as ans_2,
 coalesce(a.ans_3,   t1.ans_3) as ans_3,
 coalesce(a.load_id, t1.load_id) as load_id
from proc_fin a
--
inner join proc_tmp b on a.subs_id = b.subs_id
 and a.create_date = b.create_date
--
inner join (
select a.* from proc_fin a
left join proc_tmp b on a.subs_id = b.subs_id
 and a.create_date = b.create_date
where 1=1
 and b.subs_id is null
) t1 on a.subs_id = t1.subs_id
;

--select top 100 * from proc_fin2;

--select * from proc_fin2;
--select * from target_group where subs_id = 13248138;
--select * from transpon where subs_id = 13248138;
--select * from target_group_step1_1 where subs_id = 13248138;


-- логирование текущего расчета
get diagnostics ROW_CNT = row_count;
CALL uat_ca.prc_debug (proc,:load_id,session,null,'Строк по долетам: ' || trim(cast(row_cnt as VARCHAR(4000) CHARACTER SET UNICODE NOT CASESPECIFIC)));


--абоненты без долетов
insert into proc_fin2
select
 a.create_date,
 a.msisdn,
 a.subs_id,
 a.treatment_code,
 a.mark_1,
 a.mark_2,
 a.mark_3,
 a.mark_4,
 a.ans_1,
 a.ans_2,
 a.ans_3,
 a.load_id
from proc_fin a
left join (
select a.* from proc_fin a
left join proc_tmp b on a.subs_id = b.subs_id
 and a.create_date = b.create_date
where 1=1
 and b.subs_id is null
) b on a.subs_id = b.subs_id
where 1=1
 and b.subs_id is null
;

--select top 100 * from proc_fin2;


--==09 Вставка на схему

--select top 100 * from uat_ca.poll_id_459;
--select max(create_date) from uat_ca.poll_id_459;  --2022-12-12

insert into uat_ca.poll_id_473
select
 create_date,
 msisdn,
 subs_id,
 treatment_code,
 mark_1,
 mark_2,
 mark_3,
 mark_4,
 ans_1,
 ans_2,
 ans_3,
 load_id
from proc_fin2
;

-- логирование текущего расчета
get diagnostics ROW_CNT = row_count;
CALL uat_ca.prc_debug (proc,:load_id,session,null,'Строк без долетов: ' || trim(cast(row_cnt as VARCHAR(4000) CHARACTER SET UNICODE NOT CASESPECIFIC)));


drop table target_group;
drop table transpon;
drop table target_group_step1;
drop table target_group_step2;
drop table target_group_step3;
drop table proc_fin;
drop table proc_fin2;
drop table proc_tmp;

-- логирование окончания расчета данных
get diagnostics ROW_CNT = row_count;
CALL uat_ca.prc_debug (proc,:load_id,session,1,'END');


END;


--delete uat_ca.poll_id_473;

--=================================================================================================
--=================================================================================================
--=================================================================================================


select top 100 * from uat_ca.poll_id_473;

--View
replace view uat_ca.v_poll_473 as
lock row for access
select
 a.create_date,
 t2.cluster_name as cluster_name,
 t4.macroregion_name as macroregion,
 t3.region_name as region,
 'In_house Tariff' as point_name,
 a.msisdn,
 a.subs_id,
 -- treatment_code,
 case when a.ans_1 = 'Другое' then a.mark_1 end as mark_1,
 case when a.ans_2 = 'Другое' then a.mark_2 end as mark_2,
 case when a.ans_3 = 'Другое' then a.mark_3 end as mark_3,
 a.mark_4,
 a.ans_1,
 a.ans_2,
 a.ans_3
-- load_id,
from uat_ca.poll_id_473 a
--
left join prd2_dds_v.phone_number_2 t1 on a.msisdn = t1.msisdn
 and (a.create_date >= t1.stime and a.create_date < t1.etime)
--
left join prd2_dic_v.branch t2 on t1.branch_id = t2.branch_id
left join prd2_dic_v.region t3 on t2.region_id = t3.region_id
left join prd2_dic_v.macroregion t4 on t3.macroregion_id = t4.macroregion_id
;


--=================================================================================================

create multiset table uat_ca.poll_id_473 (
 create_date date format 'yy/mm/dd',
 msisdn varchar(20) character set unicode not casespecific,
 subs_id decimal(12,0),
 treatment_code varchar(9) character set unicode not casespecific,
 mark_1 varchar(1024) character set unicode not casespecific,
 mark_2 varchar(1024) character set unicode not casespecific,
 mark_3 varchar(1024) character set unicode not casespecific,
 mark_4 varchar(1024) character set unicode not casespecific,
 ans_1 varchar(1024) character set unicode not casespecific,
 ans_2 varchar(1024) character set unicode not casespecific,
 ans_3 varchar(1024) character set unicode not casespecific,
 load_id integer)
primary index (subs_id)
;

